/******************************************************************************** Copyright (c) 2011，中兴通讯股份有限公司，All rights reserved.** 文件名称：iscsi_initiator.cpp* 文件标识：见配置管理计划书* 内容摘要：* 当前版本：1.0* 作    者：王德恩* 完成日期：2012.03.01** 修改记录1：*    修改日期：2012.03.01*    版 本 号：V1.0*    修 改 人：王德恩*    修改内容：创建*******************************************************************************/#include "iscsi.h"#include "log_agent.h"#include "storage.h"#include <boost/regex.hpp>using namespace boost;//##########################################//#### 全局变量定义              ###########//##########################################int isSCSIDebugPrint =0;//是否进行debug打印，0:不打印,1:打印//##########################################//#### 类型定义                  ###########//##########################################typedef string::size_type (string::*find_t)(const string& delim,        string::size_type offset) const;static void print(string  sHead,int level,const string &str);int RunIscsiCmd(const string& cmd, string& result){    vector<string> v_result;    vector<string>::iterator it;    int32 ret;        ret = RunCmd(cmd,v_result);    if(SUCCESS == ret)    {        it = v_result.begin();        while(it != v_result.end())        {            result += (*it);            ++it;        }     }    else    {        result="";    }        return ret;}//##############################################//##    实现函数(需要移动的实现函数的文件中)  ##//##############################################//根据TargetName、Lun获取设备名称DeviceNameint iscsiadmGetLunDeviceName(const string &ip,const string &strTargetName,int iLun,string &strDeviceName){        int    ret=ERROR;    string sResult;       string strLun;            strLun = to_string<int>(iLun,dec);    print(LOG_SCSI_STRHEAD,LOG_SCSI_DEBUG,"iscsiadmGetLunDeviceName("+strTargetName+","+strLun+")" );    //入参判断    if (strTargetName.empty())    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmGetLunDeviceName strTargetName empty,Failed!" );        return ISCSIADM_PARAMATE_FAIL;    }    string file="/dev/disk/by-path/";    file+="ip-";    file+=ip;    file+=":3260-iscsi-";    file+=strTargetName;    file+="-lun-";    file+=strLun;    char buf[80];    memset(buf,0,80);    struct stat file_state;    if(0 != stat(file.c_str(),&file_state))    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmGetLunDeviceName file:"+file+"not exist!");        return ERROR;    }       if(readlink(file.c_str() ,buf,80) > 0)    {        string device=buf;        device=device.substr(device.find_last_of('/')+1);        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmGetLunDeviceName device:"+device);        strDeviceName=device;        ret=SUCCESS;    }    else    {        ret=ERROR;        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmGetLunDeviceName readlink :"+file+" Failed!" );    }    return ret;}int deldisk_bypath(string &file){    char buf[80];    memset(buf,0,80);    string multipath_name;    string strCmd;    int ret=ERROR;    string sResult;    struct stat file_state;     if(0 != stat(file.c_str(),&file_state))    {        //设备已经回收，直接返回成功        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmDelDevice file:"+file+" not exist!");        return SUCCESS;    }            if(readlink(file.c_str() ,buf,80) > 0)    {        string device=buf;        device=device.substr(device.find_last_of('/')+1);        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmDelDevice device:"+device);        /*移除多路径设备*/        if(getmultipath_name(device,multipath_name))        {#if 0            if(0==multipath_name.compare(0,4,"mpath",4))            {                strCmd="multipath -f "+multipath_name;            }            else            {                strCmd="superpath -f "+multipath_name;            }            if(SUCCESS!=RunCmd(strCmd,sResult))            {                 print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmDelDevice del multipath cmd:"+strCmd+"faild ");                 return ERROR;            }              if(getmultipath_name(device,multipath_name))            {                print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmDelDevice del multipath cmd:"+strCmd+"multipath:"+multipath_name+"still exist! ");                return ERROR;            }#endif                    }        else        {            print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"deldisk_bypath: getmultipath_name "+device+" failed!");            return ERROR;        }                /*移除挂载射设备*/        strCmd="echo 1 >  /sys/block/" ;        strCmd+=device;        strCmd+="/device/delete";        RunCmd(strCmd,sResult);        if(0 != stat(file.c_str(),&file_state))        {                        ret=SUCCESS;        }        else//设备仍然存在        {            print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmDelDevice: cmd:"+strCmd+" device:"+device+" still exist! ");               ret=ERROR;        }    }    else    {        ret=ERROR;        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmDelDevice readlink :"+file+" Failed!" );    }    return ret;}int iscsiadmDelDevice(const string &satype, string &targetName,const string &ip,int iLun){    int ret=ERROR;    string strLun;         strLun = to_string<int>(iLun,dec);    print(LOG_SCSI_STRHEAD,LOG_SCSI_DEBUG,"iscsiadmDelDevice("+targetName+","+strLun+")" );        string strTargetName;     if (satype==LOCALSAN)    {        strTargetName=targetName;    }    else if (satype==IPSAN)    {                ret=GetTargetNameByIp(ip,strTargetName);        if(SUCCESS==ret)        {            targetName=strTargetName;        }        else if(ret==ERROR_OBJECT_NOT_EXIST)        {            print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmDelDevice: ipsan ip: "+ip+"not loaded,SUCCESS!" );            return SUCCESS;        }    }    if (targetName.empty())    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmDelDevice targetName empty,Failed!" );        return ERROR;    }    string file="/dev/disk/by-path/";    file+="ip-";    file+=ip;    file+=":3260-iscsi-";    file+=strTargetName;    file+="-lun-";    file+=strLun;          vector<int>vec_lunid;    vec_lunid.push_back(iLun);    if(SUCCESS!=update_iscsirec(false,strTargetName,vec_lunid))    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmDelDevice:update_iscsirec  Failed!" );        return ERROR;    }    return deldisk_bypath(file);    }//判断是否已经连接iscis服务器int  GetTargetStatus(const string &satype,const string &targetName,const string &ip,bool &empty){    string strCmd;       string sResult;    string::size_type start;    int ret=ERROR;    empty =false;    string strTargetName;    if (satype==LOCALSAN)    {        strTargetName=targetName;    }    else if (satype==IPSAN)    {            if(ERROR_OBJECT_NOT_EXIST==GetTargetNameByIp(ip, strTargetName))        {                  empty=true;            return SUCCESS;        }            }    if (strTargetName.empty())    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmScsiServer targetName empty,Failed!" );        return ISCSIADM_PARAMATE_FAIL;    }        strCmd.append(STR_CMD_ISCSIADM_SESSION);       strCmd.append(STR_CMD_ISCSI_LINE);       strCmd.append(STR_CMD_ISCSIADM_SESSION_GREP);    strCmd.append(STR_CMD_ISCSI_LINE);    strCmd.append(STR_CMD_ISCSIADM_SESSION_AWK);    strCmd.append(STR_CMD_ISCSI_LINE);    strCmd.append(STR_CMD_ISCSIADM_SEDNULL);    //执行命令，返回结果    ret=RunIscsiCmd(strCmd,sResult);    if ((SUCCESS == ret) && !sResult.empty())    {        string strMatch=STR_ISCSI_BIG_BRACKET_LEFT+strTargetName+STR_ISCSI_BIG_BRACKET_RIGHT;        string strNextMatch=STR_ISCSI_BIG_BRACKET_LEFT;        string strSubStr;        bool bSubStrByMatchRes=false;        bSubStrByMatchRes=getSubStrByMatch(sResult,strMatch , strNextMatch, strSubStr);        if (!bSubStrByMatchRes)        {            print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"GetTargetStatus getSubStrByMatch("+sResult+","+strMatch+","+strNextMatch+") failed" );            return ISCSIADM_MATCH_TARGET_FAIL;        }                strMatch="@"+ip+"@";        strNextMatch="@";        bSubStrByMatchRes=getSubStrByMatch(strSubStr,strMatch,strNextMatch,strSubStr);        if (!bSubStrByMatchRes)        {            print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"isTargetEmpty getSubStrByMatch("+sResult+","+strMatch+","+strNextMatch+") failed" );            return ISCSIADM_MATCH_TARGET_FAIL;        }                start=strSubStr.find("(");        if(start == string::npos)        {            empty=true;            }                   }         else if(ret!=SUCCESS)    {                print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"isTargetEmpty cmd  failed" );            }    return ret;}//只有ipsan的调用此函数int  GetTargetNameByIp(const string &ip, string &strTargetName){    string strCmd;       string sResult;      int ret=ERROR;          strCmd.append(STR_CMD_ISCSIADM_SESSION);       strCmd.append(STR_CMD_ISCSI_LINE);       strCmd.append(STR_CMD_ISCSIADM_SESSION_GREP);    strCmd.append(STR_CMD_ISCSI_LINE);    strCmd.append(STR_CMD_ISCSIADM_SESSION_AWK);    strCmd.append(STR_CMD_ISCSI_LINE);    strCmd.append(STR_CMD_ISCSIADM_SEDNULL);        //执行命令，返回结果    ret=RunIscsiCmd(strCmd,sResult);         if ((SUCCESS == ret) && !sResult.empty())    {                string strMatch="@"+ip+"@";        string::size_type start;              // 开始的位置        string::size_type end;                // 结束的位置                string::size_type endCut;                  endCut=sResult.find(strMatch);        if (endCut == string::npos)        {            print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,sResult+"find: " +strMatch+" not exist" );            return ERROR_OBJECT_NOT_EXIST;        }                sResult=sResult.substr(0,endCut);        start=sResult.find_last_of("{");        if (start == string::npos)        {            print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,sResult+"find { failed" );                    return ERROR;        }        end=sResult.find_last_of("}");        if (end == string::npos)        {            print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,sResult+"find } failed" );                    return ERROR;        }        strTargetName=sResult.substr(start+1,end-start-1);            }    else if(sResult.empty())    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"GetTargetNameByIp : no active action");          ret=ERROR_OBJECT_NOT_EXIST;    }    else if(ret!=SUCCESS)    {                print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"GetTargetNameByIp cmd :" +strCmd+"failed" );            }        return ret;}int iscsiadmTarget(int iType,string strServerIP,string &strServerPort,string strTargetName){    string strCmd;    bool bRes=false;       strCmd.clear();    strCmd.append(STR_CMD_ISCSIADM_NODE);    strCmd.append(STR_CMD_ISCSIADM_REC);    if (REC_NEW==iType)    {        strCmd.append(" new ");    }    else if (REC_DELETE==iType)    {        strCmd.append(" delete ");    }    strCmd.append(STR_CMD_ISCSIADM_TARGET);    strCmd.append(strTargetName);    if (REC_NEW==iType)    {        strCmd.append(STR_CMD_ISCSIADM_P);        strCmd.append(strServerIP);        strCmd.append(":");        strCmd.append(strServerPort);    }    bRes = scsiSystem(strCmd);    if (bRes)    {        return ISCSIADM_SUCESS;    }    else    {                return ISCSIADM_SYSTEM_FAIL;    }}//更新白名单int update_iscsirec(bool add,string &target_name,vector<int> & vec_lunid){    struct stat file_state;         vector<int>::iterator it_lunid;        vector<string>::iterator it_target;    int err;    for (it_lunid = vec_lunid.begin(); ((vec_lunid.size()!= 0)&&(it_lunid!= vec_lunid.end())); ++it_lunid)    {        string file=TARGETID_DIR;          file+=target_name;        file+=":";        file+=to_string<int>(*it_lunid,dec);        int mode = S_IRWXU | S_IRGRP | S_IROTH;         if(add)        {            int fd=creat(file.c_str(),mode);            if(fd ==-1)            {                err=errno;            }            else            {                close(fd);            }            if(stat(file.c_str(),&file_state)!=0)                       {                                print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"update_iscsirec:  create file"+file+"error:"+to_string<int>(err,dec));                return ERROR;            }        }        else        {            if(0!=unlink(file.c_str()))            {                err=errno;            }            if(stat(file.c_str(),&file_state)==0)                                               {                               print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"update_iscsirec:  delete file"+file+"error:"+to_string<int>(err,dec));                return ERROR;            }                    }                      }    return SUCCESS;    }void guard_iscsirec(){      DIR *ptDir = NULL;    string target_name;    string strlun;    string filename;    regex expression("ip-(\\d{1,3}(\\.\\d{1,3}){3}):3260-iscsi-.*-lun-\\d{1,3}");    vector<string>::iterator it_target;    struct stat file_state;    struct dirent *ptDirent = NULL;    ptDir = opendir("/dev/disk/by-path/");    if (NULL == ptDir)    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"BlockAdaptorDataPlane::Init read TARGETID_DIR Failed!!");        return ;    }    while (NULL != (ptDirent = readdir(ptDir)))    {        string name;        /*把当前目录.，上一级目录..及隐藏文件都去掉，避免死循环遍历目录*/        if (strncmp(ptDirent->d_name, ".", 1) == 0)        {            continue;        }        name=ptDirent->d_name;                       if(!regex_match(name,expression))        {            continue;        }        string::size_type start;              // 开始的位置        string::size_type end;          start=name.find("iscsi-");        end  =name.find_last_of("-lun");         target_name=name.substr(start+6,end-4-(start+6));        end  =name.find_last_of("lun-");         strlun=name.substr(end+1);        filename=TARGETID_DIR;        filename+=target_name+":"+strlun;        if(stat(filename.c_str(),&file_state)!=0)//白名单里面没有，则删除        {            name="/dev/disk/by-path/"+name;            deldisk_bypath(name);        }                   }      closedir(ptDir);     }//连接iscis服务器int iscsiadmScsiServer(const string &satype,int iType,const string &strServerIP,string &targetName,vector<int> & vec_lunid,Mutex &login_mutex){    string strCmd;    string strTargetName;    bool bRes=false;    bool bResIsLogin=false;    bool bDiscoveryScsiServer=true;    string strServerPort;    strServerPort = "3260";    print(LOG_SCSI_STRHEAD,LOG_SCSI_DEBUG , "iscsiadmScsiServer(" + to_string<int>(iType, dec)+","+strServerIP+","+strServerPort+","+strTargetName+").");    //入参判断    if (strServerIP.empty())    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmScsiServer strServerIP empty,Failed!" );        return ISCSIADM_PARAMATE_FAIL;    }        if (satype==LOCALSAN)    {        bDiscoveryScsiServer=isDiscoveryScsiServer(strServerIP,strServerPort,strTargetName);        strTargetName=targetName;            }    else if (satype==IPSAN)    {        if(iType==SCSI_LOGIN)        {            bDiscoveryScsiServer=isDiscoveryScsiServer(strServerIP,strServerPort,strTargetName);        }        else        {                        if(ERROR_OBJECT_NOT_EXIST==GetTargetNameByIp(strServerIP, strTargetName))            {                                return SUCCESS;            }                    }        targetName=strTargetName;    }    if (targetName.empty())    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmScsiServer targetName empty,Failed!" );        return ISCSIADM_PARAMATE_FAIL;    }        strCmd.clear();    strCmd.append(STR_CMD_ISCSIADM_NODE);    strCmd.append(STR_CMD_ISCSIADM_TARGET);    strCmd.append(strTargetName);    strCmd.append(STR_CMD_ISCSIADM_P);    strCmd.append(strServerIP);    strCmd.append(":");    strCmd.append(strServerPort);        //判断是否登入    bResIsLogin = isLoginScsiServer(satype,strServerIP,strServerPort,strTargetName);      if(SCSI_LOGIN==iType && !bResIsLogin)    {              login_mutex.Lock();        bResIsLogin = isLoginScsiServer(satype,strServerIP,strServerPort,strTargetName);          if(bResIsLogin)        {            login_mutex.Unlock();        }    }    switch (iType)    {    case SCSI_LOGIN:        //连接iscis服务器    {        if (!bDiscoveryScsiServer)        {            //没有发现指定的服务器            print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmScsiServer(SCSI_LOGIN) ,not find DiscoveryScsiServer.Failed to LOGIN! " );            if (!bResIsLogin)            {                login_mutex.Unlock();            }            return ISCSIADM_NOT_DISCOVERY_SCSISERVER;        }        if(SUCCESS!=update_iscsirec(true,strTargetName,vec_lunid))        {            print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmScsiServer:update_iscsirec  Failed!" );            return ERROR;        }        if (bResIsLogin)        {            strCmd.append(STR_CMD_ISCSIADM_REFRESH);        }        else        {                       strCmd.append(STR_CMD_ISCSIADM_LOGIN);        }        break;    }    case SCSI_LOGOUT:    {//登出        strCmd.append(STR_CMD_ISCSIADM_LOGOUT);        if (!bResIsLogin)        {            //没有登入 不需要退出            print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmScsiServer(SCSI_LOGOUT) not login server.not need LOGOUT again!" );            return ISCSIADM_SUCESS;        }                break;    }    case SCSI_REFEASH:    {//刷新        strCmd.append(STR_CMD_ISCSIADM_REFRESH);        if (!bResIsLogin)        {            //没有登入 无法刷新            print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmScsiServer(SCSI_REFEASH) not login server.not need LOGOUT again!" );            return ISCSIADM_ALREADY_NOTLOGIN;        }        if (!bDiscoveryScsiServer)        {            //没有发现指定的服务器            print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmScsiServer(SCSI_REFEASH) ,not find DiscoveryScsiServer.Failed to LOGOUT!" );            return ISCSIADM_NOT_DISCOVERY_SCSISERVER;        }        break;    }    default:        strCmd.clear();        break;    }    string rm_cmd("rm -rf ");    rm_cmd = rm_cmd+ iscsi_node_path+strTargetName;    bool retry=false;relogin:    bRes = scsiSystem(strCmd);    if (bRes)    {        if (SCSI_LOGOUT==iType)        {            iscsiadmTarget(REC_DELETE,strServerIP,strServerPort,strTargetName);            /*有时候删不干净，从而导致再次装载失败，这边强行清除下*/                         system(rm_cmd.c_str());        }        else if(SCSI_LOGIN==iType && !bResIsLogin)        {                        while(!isLoginScsiServer(satype,strServerIP,strServerPort,strTargetName))                    {                Delay(1000);             }            login_mutex.Unlock();            }        return ISCSIADM_SUCESS;    }    else    {        if (SCSI_LOGIN==iType && !bResIsLogin)        {            iscsiadmTarget(REC_DELETE,strServerIP,strServerPort,strTargetName);                        system(rm_cmd.c_str());            if(!retry)            {                retry=true;                goto relogin;            }            login_mutex.Unlock();          }               print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"iscsiadmScsiServer,scsiSystem <"+strCmd+"> Failed!" );        return ISCSIADM_SYSTEM_FAIL;    }}//判断是能够发现指定iscis服务器bool isDiscoveryScsiServer(const string & strServerIP,const string & strServerPort,string & strTargetName){    string strCmd;    string sResult;    int    ret;    print(LOG_SCSI_STRHEAD,LOG_SCSI_DEBUG,"isDiscoveryScsiServer("+strServerIP+","+strServerPort+","+strTargetName+").");    //入参判断    if (strServerIP.empty())    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"isDiscoveryScsiServer strServerIP empty,Failed!" );        return false;    }    if (strServerPort.empty())    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"isDiscoveryScsiServer strServerPort empty,Failed!" );        return false;    }    strCmd.clear();    strCmd.append(STR_CMD_ISCSIADM_DISCOVERY);    strCmd.append(strServerIP);    strCmd.append(STR_CMD_ISCSI_LINE);    strCmd.append(STR_CMD_ISCSI_GREP);    strCmd.append(strServerIP);    strCmd.append(STR_CMD_ISCSI_LINE);    strCmd.append(STR_CMD_ISCSIADM_AWK);#if 0    strCmd.append(STR_CMD_ISCSI_LINE);    strCmd.append(STR_CMD_ISCSIADM_SEDNULL);#endif    //执行命令，返回结果    ret=RunCmd(strCmd,sResult);    if ((SUCCESS == ret) && !sResult.empty())    {        strTargetName=sResult.substr(0,sResult.size()-1);        //strTargetName=sResult;        return true;    }    return false;}//判断是否已经连接iscis服务器bool isLoginScsiServer(const string &satype,const string &strServerIP,string &strServerPort,const string &strTargetName){    string strCmd;    bool bRes=false;    string sResult;    string::size_type start;    int ret=ERROR;    strCmd.clear();    strCmd.append(STR_CMD_ISCSIADM_SESSION);       strCmd.append(STR_CMD_ISCSI_LINE);       strCmd.append(STR_CMD_ISCSIADM_SESSION_GREP);    strCmd.append(STR_CMD_ISCSI_LINE);    strCmd.append(STR_CMD_ISCSIADM_SESSION_AWK);    strCmd.append(STR_CMD_ISCSI_LINE);    strCmd.append(STR_CMD_ISCSIADM_SEDNULL);    //执行命令，返回结果    ret=RunIscsiCmd(strCmd,sResult);    if ((SUCCESS == ret) && !sResult.empty())    {        string strMatch=STR_ISCSI_BIG_BRACKET_LEFT+strTargetName+STR_ISCSI_BIG_BRACKET_RIGHT;        string strSubStr;        bool   ret;        ret=getSubStrByMatch(sResult,strMatch , "{", strSubStr);        if(ret==true)        {                               start=strSubStr.find(strServerIP);            if(start != string::npos)            {//找到对应的信息 表示已经登陆                bRes=true;                }        }                }       return bRes;}//获取Target-Lun-Disk的函数 获取所有的target lun disk//****待后续功能扩展****bool splitLunDisk(const string &strTmp){    vector<string>  vStrTemp;    string strCoutTmp;    string strLastCharTmp;    if (strTmp.empty())    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"splitLunDisk error.strTmp is empty." );        return false;    }    print(LOG_SCSI_STRHEAD,LOG_SCSI_DEBUG,"splitLunDisk strTmp:"+strTmp );    strSplit(strTmp,"{",true,true,vStrTemp);    for (vector<string>::iterator it=vStrTemp.begin();it!=vStrTemp.end();++it)    {        vector<string>  vStrSubLunDisk;        //cout<<"all:"<<*it<<endl;        print(LOG_SCSI_STRHEAD,LOG_SCSI_DEBUG,"all:"+*it );        strSplit(*it,"[",true,true,vStrSubLunDisk);        for (vector<string>::iterator subit=vStrSubLunDisk.begin();subit!=vStrSubLunDisk.end();++subit)        {            if (subit == vStrSubLunDisk.begin())            {                //第一个是target                deleteStrLastChar(*subit,strCoutTmp,strLastCharTmp);                print(LOG_SCSI_STRHEAD,LOG_SCSI_DEBUG,"target:"+strCoutTmp+" strLastCharTmp:"+strLastCharTmp);                //****待后续功能扩展****            }            else            {                vector<string>  vStrSubDisk;                //lun与磁盘信息                //print(LOG_SCSI_STRHEAD,LOG_SCSI_DEBUG,"Lun disk:"+*subit );                strSplit(*subit,"(",true,true,vStrSubDisk);                for (vector<string>::iterator subDiskit=vStrSubDisk.begin();subDiskit!=vStrSubDisk.end();++subDiskit)                {                    if (subDiskit == vStrSubDisk.begin())                    {                        //第一个是Lun                        deleteStrLastChar(*subDiskit,strCoutTmp,strLastCharTmp);                        print(LOG_SCSI_STRHEAD,LOG_SCSI_DEBUG,"Lun:"+strCoutTmp+" strLastCharTmp:"+ strLastCharTmp);                        //****待后续功能扩展****                    }                    else                    {                        //第2个是Disk                        deleteStrLastChar(*subDiskit,strCoutTmp,strLastCharTmp);                        print(LOG_SCSI_STRHEAD,LOG_SCSI_DEBUG,"disk:"+strCoutTmp+" strLastCharTmp:"+ strLastCharTmp);                        //****待后续功能扩展****                    }                }            }        }    }    return true;}//##############################################//## 通用函数(需要移动的通用函数的文件中)  ##//##############################################//输出打印函数//入参 sHead:打印的头，如<scsi>//     level:输出级别//     str：需要输出的字符串(调用时不需要加换行，本函数自动在后面加换行标记)static void print(string  sHead,int level,const string &str){    switch (level)    {    case LOG_SCSI_ERROR:    {        OutPut(SYS_ERROR, "%s  %s \n",sHead.c_str(),str.c_str());        break;    }    case LOG_SCSI_DEBUG:    {        if (0 == isSCSIDebugPrint)        {//如果不显示打印，则不打印debug打印            return;        }        OutPut(SYS_ERROR, "%s  %s \n",sHead.c_str(),str.c_str());        break;    }    default :        break;    }}//执行linux命令，可以获取到命令执行是否成功，无返回结果//入参 sCommand :linux命令bool scsiSystem(const string &sCommand){    //pid_t status;    int status;    if (sCommand.empty())    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"RunCmd:sCommand empty" );        return false;    }    print(LOG_SCSI_STRHEAD,LOG_SCSI_DEBUG,"scsiSystem:"+sCommand );    status = system(sCommand.c_str());    if (-1 == status)    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"run system error 1!status:"+to_string<int>(status, dec)+" Command: "+sCommand);        return false;    }    else    {        if (WIFEXITED(status))        {            if (0 == WEXITSTATUS(status))            {                return true;            }            else            {                print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"run system error 2!status:" + to_string<int>(WEXITSTATUS(status),dec) + " Command: "+sCommand);                return false;            }        }        else        {            print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"run system error 3!status:"+to_string<int>(WEXITSTATUS(status),dec)+" Command: "+sCommand);            return false;        }    }    return false;}// 函数实现String中的split方法// 按照指定的字符分割字符串，// 入参：strOld 需要分割的字符串//       strMatch 需要匹配的符号或者字符串(按此符号分割strOld)//       isRemoveEmpty 是否需要去除空格，false:不去除空结果 true: 去除空结果//       isfullMatch 如果strMatch是字符串 需要确认是否全文匹配，//                   true: 完全匹配strMatch字符串//                   false:匹配字符串strMatch中的任意一个字符//出参  vStrResult:以vector返回分割后的string列表bool strSplit(const string& strOld,              const string& strMatch,              bool isRemoveEmpty,              bool isFullMatch,              vector<string> &vStrResult){    string::size_type start = 0;              // 开始的位置    string::size_type skip = 1;               // 步长：分离时需要移动字符的位数，默认为1    string strSubstr = "";    find_t pfind = &string::find_first_of;    vStrResult.clear();    if (strOld.empty())    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"strSplit error.strOld is empty." );        return false;    }    print(LOG_SCSI_STRHEAD,LOG_SCSI_DEBUG,"strSplit strOld:"+strOld+"\n strMatch:" +strMatch);    if (isFullMatch)    {        // 完全匹配字符串strMatch，修改步长为strMatch字符串长度，主要如果skip 为0处理        skip = strMatch.length();        pfind = &string::find;    }    //cout<<"skip:"<<skip<<endl;    while (start != string::npos)    {        // 查找匹配        string::size_type end = (strOld.*pfind)(strMatch,start);        //注意null字符串string::find与strMatch是匹配的        if (skip == 0)        {            //如果步长是0,结束标志            end = string::npos;        }        //获取子串        strSubstr = strOld.substr(start, end - start);        //判断是否需要去除空格，        //如果isRemoveEmpty为TRUE，strSubstr需要不为空，才会加入到结果集中        //如果isRemoveEmpty为FALSE，不判断strSubstr，直接加入到结果集中        if (!(isRemoveEmpty && strSubstr.empty()))        {            vStrResult.push_back(strSubstr);        }        if ((start = end) != string::npos)        {            start += skip;        }    }    return true;}//根据指定的需要配置的字符串strMatch和下一个匹配的字符 获取对应的子串(strMatch与strNextMatch之间的字符)//使用时先判断返回值//入参 strSrc:原字符串//     strMatch:需要匹配的字符串,如:{tecs:1}//     strNextMatch:需要匹配的下一个字符,如果没有定位到,表示到字符串尾部//出参 strSubStr:获取匹配的字符串所属的字符串(如：[1](sdb)[2](sdc)bool getSubStrByMatch(const string &strSrc,                      const string &strMatch,                      const string &strNextMatch,                      string &strSubStr){    string::size_type start;              // 开始的位置    string::size_type end;                // 结束的位置    string::size_type startCut;           // 开始截取字符的位置    string::size_type endCut;             // 结束截取字符的位置    string strLunDiskTmp="";    string strTmp;    strTmp=strSrc;    strSubStr = "";    if (strTmp.empty())    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"getSubStrByMatch error!strTmp is empty." );        return false;    }    if (strMatch.empty())    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"getSubStrByMatch error!strMatch is empty." );        return false;    }    if (strNextMatch.empty())    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"getSubStrByMatch error!strNextMatch is empty." );        return false;    }    print(LOG_SCSI_STRHEAD,LOG_SCSI_DEBUG,"getSubStrByMatch:strMatch:"+strMatch+" strNextMatch:"+strNextMatch+" \n from:"+strTmp);    start =strTmp.find(strMatch);    if (start != string::npos)    {        startCut = start + strMatch.length();        end=strTmp.find(strNextMatch,startCut );        if (end == string::npos)        {//没有找到 说明是到最后了            //开始获取字符串 去掉开头的{Target},截取到最后            strSubStr =  strTmp.substr(startCut);        }        else        {            endCut=end -startCut;            //开始获取字符串 去掉开头的{Target},            strSubStr =  strTmp.substr(startCut,endCut);        }        print(LOG_SCSI_STRHEAD,LOG_SCSI_DEBUG,"getSubStrByMatch:Successed!Result is <"+strSubStr+"> ");        return true;    }    else    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_DEBUG,"getSubStrByMatch:Failed!strMatch not find in strTmp!");        return false;    }}//去掉str最后一个字符(如回车换行符号)//入参: str：需要处理的字符串//出参: strRes  去掉str最后一个字符得到的字符串//      strLast 最后一个字符bool deleteStrLastChar(const string &str,string &strRes,string &strLast){    strLast.clear();    strRes.clear();    if (!str.empty())    {        strRes = str.substr(0,str.length()-1);        strLast = str.substr(str.length()-1); //最后一个字符串    }    else    {        strRes=str;    }    return true;}bool getmultipath_name(const string & device,string &name){    string strCmd;    bool bRes=false;         string sResult;    DIR *ptDir = NULL;    struct dirent *ptDirent = NULL; /* readdir函数的返回值 */    string   map_name;    string dir_name="/sys/block/";    dir_name+=device;    dir_name+="/holders";    ptDir = opendir(dir_name.c_str());    if (NULL == ptDir)    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"getmultipath_name:"+dir_name+" Failed!!");        return false;    }    while (NULL != (ptDirent = readdir(ptDir)))    {        /*把当前目录.，上一级目录..及隐藏文件都去掉，避免死循环遍历目录*/        if (strncmp(ptDirent->d_name, ".", 1) == 0)        {            continue;        }        map_name=ptDirent->d_name;        break;    }    closedir(ptDir);    if(map_name.empty())    {        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"getmultipath_name:device:"+ device+" map not exist ");        return false;    }        dir_name+="/";    dir_name+=map_name;    dir_name+="/dm/name";       strCmd="cat ";    strCmd+=dir_name;        //执行命令，返回结果    bRes=RunCmd(strCmd,sResult);    if ((SUCCESS == bRes) && !sResult.empty())    {        name=sResult.substr(0,sResult.size()-1);        print(LOG_SCSI_STRHEAD,LOG_SCSI_ERROR,"getmultipath_name: name :"+name);        return true;    }    return false;    }bool GetIscsiName(string &iscsiname){    string strCmd,sResult;    strCmd.append("cat /etc/iscsi/initiatorname.iscsi  |sed 's/InitiatorName=//'");    int bRes;    //执行命令，返回结果    bRes=RunCmd(strCmd,sResult);    if ((SUCCESS == bRes) && !sResult.empty())    {        iscsiname=sResult.substr(0,sResult.size()-1);        return true;    }    return false;}void DbgDelDevice(char *type, char * targetname,char *ip,int lun){    string strtargetname=targetname;    int ret;    ret=iscsiadmDelDevice(type,strtargetname,ip,lun);    printf("iscsiadmDelDevice  ret :%d\n",ret);}void DbgGetDeviceName(char *ip,char * targetname,int lun){    string strDeviceName;    iscsiadmGetLunDeviceName(ip,targetname,lun,strDeviceName);    printf("name is %s \n",strDeviceName.c_str());}void DbgGetMultipathName(char *dev){    string name;    getmultipath_name(dev,name);    printf("name is %s \n",name.c_str());}void DbgGetTargetName(char *ip){    string name;    GetTargetNameByIp(ip,name);    printf("name is %s \n",name.c_str());}DEFINE_DEBUG_FUNC(DbgGetMultipathName);DEFINE_DEBUG_FUNC(DbgDelDevice);DEFINE_DEBUG_FUNC(DbgGetDeviceName);DEFINE_DEBUG_FUNC(DbgGetTargetName);void dbg_show_iscsiname(){    string name;    GetIscsiName (name);    printf("name is %s \n",name.c_str());}DEFINE_DEBUG_FUNC(dbg_show_iscsiname);void dbg_iscsi_open_debug_print(){    isSCSIDebugPrint = 1;}DEFINE_DEBUG_FUNC(dbg_iscsi_open_debug_print);void dbg_iscsi_close_debug_print(){    isSCSIDebugPrint = 0;}DEFINE_DEBUG_FUNC(dbg_iscsi_close_debug_print);DEFINE_DEBUG_FUNC(guard_iscsirec);//***********************//***     END         ***//***********************